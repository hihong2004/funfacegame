<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Face Crush - Match 3 faces game">
  <title>Face Crush - Fun Face Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow-x: hidden;
    }
    .container { width: 100%; max-width: 600px; padding: 20px; }
    
    /* è¿”å›æŒ‰éˆ• */
    .back-button {
      position: fixed; top: 20px; left: 20px;
      background: white; border: none; border-radius: 50%;
      width: 48px; height: 48px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transition: all 0.2s; z-index: 100;
    }
    .back-button:hover { transform: scale(1.1); }
    .back-button:active { transform: scale(0.95); }
    
    /* éšæ®µå®¹å™¨ */
    .phase { display: none; }
    .phase.active { display: block; animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    
    /* ä¸»é¡Œé¸æ“‡ */
    .theme-selector {
      background: white; border-radius: 24px;
      padding: 32px; box-shadow: 0 20px 40px rgba(0,0,0,0.15);
    }
    .theme-title { font-size: 28px; font-weight: 800; text-align: center; color: #1e293b; margin-bottom: 8px; }
    .theme-subtitle { text-align: center; color: #64748b; margin-bottom: 24px; }
    .theme-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 24px; }
    .theme-card {
      padding: 24px 16px; border: 3px solid #e2e8f0; border-radius: 16px;
      text-align: center; cursor: pointer; transition: all 0.2s; background: white;
    }
    .theme-card:hover { border-color: #a5b4fc; transform: translateY(-4px) scale(1.02); box-shadow: 0 8px 20px rgba(99,102,241,0.2); }
    .theme-card:active { transform: translateY(0) scale(0.98); }
    .theme-card.selected { border-color: #6366f1; background: #eef2ff; box-shadow: 0 0 0 4px rgba(99,102,241,0.2); }
    .theme-icon { font-size: 48px; margin-bottom: 12px; transition: transform 0.2s; }
    .theme-card:hover .theme-icon { transform: scale(1.2) rotate(-5deg); }
    .theme-name { font-size: 16px; font-weight: 700; color: #1e293b; }
    
    /* æŒ‰éˆ• */
    .action-button {
      width: 100%; padding: 16px; border: none; border-radius: 12px;
      font-weight: 700; font-size: 16px; cursor: pointer;
      transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px;
    }
    .action-button:disabled { opacity: 0.5; cursor: not-allowed; }
    .action-button.primary { background: #6366f1; color: white; box-shadow: 0 4px 16px rgba(99,102,241,0.3); }
    .action-button.primary:hover:not(:disabled) { background: #4f46e5; transform: translateY(-2px); box-shadow: 0 6px 20px rgba(99,102,241,0.4); }
    .action-button.primary:active:not(:disabled) { transform: translateY(0); }
    .action-button.secondary { background: #f1f5f9; color: #1e293b; }
    .action-button.secondary:hover:not(:disabled) { background: #e2e8f0; }
    
    /* ç…§ç‰‡ä¸Šå‚³ */
    .photo-upload { background: white; border-radius: 24px; padding: 32px; box-shadow: 0 20px 40px rgba(0,0,0,0.15); }
    .upload-title { font-size: 28px; font-weight: 800; text-align: center; color: #1e293b; margin-bottom: 8px; }
    .upload-subtitle { text-align: center; color: #64748b; margin-bottom: 24px; }
    .upload-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 24px; }
    .upload-slot {
      aspect-ratio: 1; border: 3px dashed #cbd5e1; border-radius: 50%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      cursor: pointer; transition: all 0.2s; position: relative; overflow: hidden; background: #f8fafc;
    }
    .upload-slot:hover { border-color: #6366f1; background: #eef2ff; transform: scale(1.05); }
    .upload-slot.main { border-color: #ef4444; border-style: solid; }
    .upload-slot.filled { border-style: solid; border-color: #22c55e; }
    .upload-slot.filled img { width: 100%; height: 100%; object-fit: cover; border-radius: 50%; }
    .upload-slot.processing { border-color: #f59e0b; }
    .upload-slot.error { border-color: #ef4444; background: #fef2f2; }
    .upload-icon { font-size: 32px; color: #cbd5e1; }
    .upload-label { font-size: 11px; font-weight: 700; color: #94a3b8; margin-top: 4px; text-align: center; }
    .slot-badge { position: absolute; top: -4px; right: -4px; background: #ef4444; color: white; font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 8px; z-index: 10; }
    .slot-status { position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; font-size: 9px; padding: 2px 6px; border-radius: 4px; white-space: nowrap; }
    
    /* è™•ç†ä¸­å‹•ç•« */
    .upload-slot.processing::after {
      content: ''; position: absolute; inset: 0;
      border: 3px solid transparent; border-top-color: #f59e0b;
      border-radius: 50%; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* éŠæˆ²å€åŸŸ */
    .game-area { background: white; border-radius: 24px; padding: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.15); }
    .game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding: 12px; background: #f8fafc; border-radius: 12px; }
    .game-stat { text-align: center; }
    .game-stat-label { font-size: 12px; color: #64748b; font-weight: 600; }
    .game-stat-value { font-size: 24px; font-weight: 800; color: #1e293b; }
    .game-board { display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; margin-bottom: 16px; }
    .game-cell {
      aspect-ratio: 1; border-radius: 50%; display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: all 0.15s; font-size: 20px; user-select: none;
      border: 2px solid rgba(255,255,255,0.3); overflow: hidden;
    }
    .game-cell:hover { transform: scale(1.15); z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .game-cell:active { transform: scale(0.9); }
    .game-cell img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
    .game-cell.selected { box-shadow: 0 0 0 4px #6366f1, 0 4px 12px rgba(0,0,0,0.3); transform: scale(1.15); z-index: 10; }
    .game-cell.matched { animation: matchPop 0.3s ease forwards; }
    @keyframes matchPop { 0% { transform: scale(1); } 50% { transform: scale(1.4); opacity: 0.5; } 100% { transform: scale(0); opacity: 0; } }
    
    /* éé—œå½ˆçª— */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: none; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); }
    .modal-overlay.show { display: flex; }
    .modal-content { background: white; border-radius: 24px; padding: 32px; max-width: 400px; width: 90%; text-align: center; animation: bounceIn 0.4s ease; }
    @keyframes bounceIn { 0% { transform: scale(0.5); opacity: 0; } 70% { transform: scale(1.05); } 100% { transform: scale(1); opacity: 1; } }
    .modal-title { font-size: 36px; font-weight: 900; background: linear-gradient(135deg, #a855f7, #ec4899); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 16px; }
    .modal-score { font-size: 48px; font-weight: 800; color: #1e293b; margin-bottom: 24px; }
    .modal-buttons { display: flex; gap: 12px; }
    .modal-buttons button { flex: 1; }
    
    /* æç¤ºå½ˆçª— */
    .toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); background: #1e293b; color: white; padding: 12px 24px; border-radius: 12px; font-weight: 600; z-index: 2000; animation: toastIn 0.3s ease; }
    @keyframes toastIn { from { opacity: 0; transform: translateX(-50%) translateY(20px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
    
    /* éŸ³æ•ˆé–‹é—œ */
    .sound-toggle { position: fixed; top: 20px; right: 20px; background: white; border: none; border-radius: 50%; width: 48px; height: 48px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.15); font-size: 24px; z-index: 100; transition: all 0.2s; }
    .sound-toggle:hover { transform: scale(1.1); }
  </style>
</head>
<body>
  <!-- è¿”å›æŒ‰éˆ• -->
  <button class="back-button" onclick="goBack()">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#1e293b" stroke-width="2.5"><polyline points="15 18 9 12 15 6"></polyline></svg>
  </button>
  
  <!-- éŸ³æ•ˆé–‹é—œ -->
  <button class="sound-toggle" id="sound-toggle" onclick="toggleSound()">ğŸ”Š</button>

  <div class="container">
    <!-- éšæ®µ 1ï¼šä¸»é¡Œé¸æ“‡ -->
    <div id="phase-theme" class="phase active">
      <div class="theme-selector">
        <h1 class="theme-title">Choose Theme</h1>
        <p class="theme-subtitle">Select a theme for your game ending</p>
        
        <div class="theme-grid">
          <div class="theme-card" data-theme="birthday" onclick="selectTheme(this)">
            <div class="theme-icon">ğŸ‚</div>
            <div class="theme-name">Birthday</div>
          </div>
          <div class="theme-card" data-theme="romance" onclick="selectTheme(this)">
            <div class="theme-icon">ğŸ’•</div>
            <div class="theme-name">Romance</div>
          </div>
          <div class="theme-card" data-theme="party" onclick="selectTheme(this)">
            <div class="theme-icon">ğŸ‰</div>
            <div class="theme-name">Party</div>
          </div>
          <div class="theme-card" data-theme="pet" onclick="selectTheme(this)">
            <div class="theme-icon">ğŸ¾</div>
            <div class="theme-name">Pet</div>
          </div>
          <div class="theme-card" data-theme="prank" onclick="selectTheme(this)">
            <div class="theme-icon">âš¡</div>
            <div class="theme-name">Prank</div>
          </div>
        </div>

        <button class="action-button primary" id="btn-continue" disabled onclick="goToPhotos()">
          Continue
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </button>
      </div>
    </div>

    <!-- éšæ®µ 2ï¼šç…§ç‰‡ä¸Šå‚³ -->
    <div id="phase-photo" class="phase">
      <div class="photo-upload">
        <h1 class="upload-title">Upload Face Photos</h1>
        <p class="upload-subtitle">ğŸ“¸ Photos will be auto-cropped to face area</p>
        
        <div class="upload-grid" id="upload-grid"></div>

        <div style="display: flex; gap: 12px;">
          <button class="action-button secondary" onclick="goToTheme()" style="flex: 1;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"></polyline></svg>
            Back
          </button>
          <button class="action-button primary" id="btn-start" onclick="startGame()" style="flex: 2;">
            Start Game
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
          </button>
        </div>
      </div>
    </div>

    <!-- éšæ®µ 3ï¼šéŠæˆ² -->
    <div id="phase-game" class="phase">
      <div class="game-area">
        <div class="game-header">
          <div class="game-stat">
            <div class="game-stat-label">LEVEL</div>
            <div class="game-stat-value" id="level-display">1</div>
          </div>
          <div class="game-stat">
            <div class="game-stat-label">SCORE</div>
            <div class="game-stat-value" id="score-display">0</div>
          </div>
          <div class="game-stat">
            <div class="game-stat-label">TARGET</div>
            <div class="game-stat-value" id="target-display">15</div>
          </div>
        </div>
        <div class="game-board" id="game-board"></div>
        <button class="action-button secondary" onclick="pauseGame()">Pause</button>
      </div>
    </div>
  </div>

  <!-- éé—œå½ˆçª— -->
  <div class="modal-overlay" id="win-modal">
    <div class="modal-content">
      <h2 class="modal-title">ğŸ‰ Level Complete!</h2>
      <div class="modal-score" id="final-score">0</div>
      <div class="modal-buttons">
        <button class="action-button secondary" onclick="goToLobby()">Lobby</button>
        <button class="action-button primary" onclick="nextLevel()">Next Level â†’</button>
      </div>
    </div>
  </div>

  <script>
    // ========== éŸ³æ•ˆç³»çµ± ==========
    const Sound = {
      ctx: null,
      enabled: true,
      
      init() {
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) { this.enabled = false; }
      },
      
      play(freq, duration, type = 'sine') {
        if (!this.enabled || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
      },
      
      click() { this.play(800, 0.08); },
      select() { this.play(600, 0.1); setTimeout(() => this.play(800, 0.1), 50); },
      match() { this.play(523, 0.1); setTimeout(() => this.play(659, 0.1), 50); setTimeout(() => this.play(784, 0.15), 100); },
      swap() { this.play(400, 0.08); setTimeout(() => this.play(500, 0.08), 50); },
      invalid() { this.play(200, 0.15, 'sawtooth'); },
      error() { this.play(150, 0.2, 'sawtooth'); setTimeout(() => this.play(100, 0.3, 'sawtooth'), 150); },
      success() { this.play(880, 0.1); setTimeout(() => this.play(1100, 0.15), 80); },
      levelUp() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => this.play(f, 0.2), i * 100)); },
      
      toggle() {
        this.enabled = !this.enabled;
        document.getElementById('sound-toggle').textContent = this.enabled ? 'ğŸ”Š' : 'ğŸ”‡';
      }
    };
    
    // ========== è‡‰éƒ¨åµæ¸¬ç³»çµ± ==========
    const FaceDetector = {
      detector: null,
      supported: false,
      
      async init() {
        // æª¢æŸ¥ç€è¦½å™¨æ˜¯å¦æ”¯æ´ Face Detection API
        if ('FaceDetector' in window) {
          try {
            this.detector = new FaceDetector({ fastMode: true, maxDetectedFaces: 5 });
            this.supported = true;
            console.log('[FaceDetector] Native API supported');
          } catch(e) {
            console.warn('[FaceDetector] Native API failed:', e);
          }
        }
        
        if (!this.supported) {
          console.log('[FaceDetector] Using fallback (center crop)');
        }
      },
      
      async detect(imgElement) {
        if (!this.supported || !this.detector) {
          return null;
        }
        
        try {
          const faces = await this.detector.detect(imgElement);
          if (faces.length > 0) {
            // è¿”å›æœ€å¤§çš„è‡‰ï¼ˆé€šå¸¸æ˜¯ä¸»è¦äººç‰©ï¼‰
            return faces.reduce((max, face) => 
              face.boundingBox.width * face.boundingBox.height > 
              max.boundingBox.width * max.boundingBox.height ? face : max
            );
          }
        } catch(e) {
          console.warn('[FaceDetector] Detection error:', e);
        }
        return null;
      },
      
      // è£åˆ‡è‡‰éƒ¨å€åŸŸ
      async cropFace(imageDataUrl) {
        return new Promise(async (resolve) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          
          img.onload = async () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const outputSize = 200; // è¼¸å‡ºå¤§å°
            
            canvas.width = outputSize;
            canvas.height = outputSize;
            
            let cropX, cropY, cropSize;
            
            // å˜—è©¦åµæ¸¬è‡‰éƒ¨
            const face = await this.detect(img);
            
            if (face) {
              // æœ‰åµæ¸¬åˆ°è‡‰éƒ¨ï¼Œæ“´å¤§è£åˆ‡ç¯„åœï¼ˆè‡‰éƒ¨ + å‘¨åœç©ºé–“ï¼‰
              const bbox = face.boundingBox;
              const padding = Math.max(bbox.width, bbox.height) * 0.5;
              
              cropX = Math.max(0, bbox.x - padding);
              cropY = Math.max(0, bbox.y - padding * 0.3); // ä¸Šæ–¹å¤šç•™ä¸€é»ï¼ˆé ­é«®ï¼‰
              cropSize = Math.min(
                bbox.width + padding * 2,
                bbox.height + padding * 1.5,
                img.width - cropX,
                img.height - cropY
              );
              
              // ç¢ºä¿æ˜¯æ­£æ–¹å½¢
              cropSize = Math.min(cropSize, img.width - cropX, img.height - cropY);
              
              console.log('[FaceDetector] Face found, cropping...');
            } else {
              // æ²’æœ‰åµæ¸¬åˆ°è‡‰éƒ¨ï¼Œä½¿ç”¨æ™ºæ…§ä¸­å¿ƒè£åˆ‡
              // å‡è¨­è‡‰éƒ¨é€šå¸¸åœ¨åœ–ç‰‡ä¸ŠåŠéƒ¨ä¸­å¤®
              const minDim = Math.min(img.width, img.height);
              cropSize = minDim * 0.8;
              cropX = (img.width - cropSize) / 2;
              cropY = (img.height - cropSize) / 3; // åä¸Šæ–¹
              
              console.log('[FaceDetector] No face detected, using smart center crop');
            }
            
            // ç¹ªè£½è£åˆ‡å¾Œçš„åœ“å½¢åœ–ç‰‡
            ctx.beginPath();
            ctx.arc(outputSize/2, outputSize/2, outputSize/2, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();
            
            ctx.drawImage(img, cropX, cropY, cropSize, cropSize, 0, 0, outputSize, outputSize);
            
            resolve({
              dataUrl: canvas.toDataURL('image/jpeg', 0.9),
              faceDetected: !!face
            });
          };
          
          img.onerror = () => {
            resolve({ dataUrl: imageDataUrl, faceDetected: false });
          };
          
          img.src = imageDataUrl;
        });
      }
    };
    
    // ========== éŠæˆ²ç‹€æ…‹ ==========
    let selectedTheme = null;
    let photos = ['ğŸ˜œ', 'ğŸ¤ª', 'ğŸ˜‚', 'ğŸ¥³', 'ğŸ˜', 'ğŸ¤“'];
    let photoStatus = [false, false, false, false, false, false]; // è¿½è¹¤å“ªäº› slot æœ‰ä¸Šå‚³
    let board = [];
    let score = 0;
    let level = 1;
    let target = 15;
    let draggedIdx = null;
    let selectedCell = null;
    const BOARD_SIZE = 8;
    const COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'];
    
    // ========== åˆå§‹åŒ– ==========
    document.addEventListener('DOMContentLoaded', async () => {
      Sound.init();
      await FaceDetector.init();
      createUploadSlots();
      console.log('[FaceCrush] Ready!');
    });
    
    // ========== Toast æç¤º ==========
    function showToast(message, duration = 3000) {
      const existing = document.querySelector('.toast');
      if (existing) existing.remove();
      
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => toast.remove(), duration);
    }
    
    // ========== å°èˆªå‡½æ•¸ ==========
    function goBack() { Sound.click(); window.location.href = '../../index.html'; }
    function goToLobby() { Sound.click(); window.location.href = '../../index.html'; }
    function toggleSound() { Sound.toggle(); }
    
    function showPhase(name) {
      document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));
      document.getElementById('phase-' + name).classList.add('active');
    }
    
    function goToTheme() { Sound.click(); showPhase('theme'); }
    function goToPhotos() { Sound.click(); showPhase('photo'); }
    
    // ========== ä¸»é¡Œé¸æ“‡ ==========
    function selectTheme(el) {
      Sound.select();
      document.querySelectorAll('.theme-card').forEach(c => c.classList.remove('selected'));
      el.classList.add('selected');
      selectedTheme = el.dataset.theme;
      document.getElementById('btn-continue').disabled = false;
    }
    
    // ========== ç…§ç‰‡ä¸Šå‚³ ==========
    function createUploadSlots() {
      const grid = document.getElementById('upload-grid');
      grid.innerHTML = '';
      for (let i = 0; i < 6; i++) {
        const slot = document.createElement('div');
        slot.className = 'upload-slot' + (i === 0 ? ' main' : '');
        slot.id = 'slot-' + i;
        slot.innerHTML = `
          ${i === 0 ? '<div class="slot-badge">â˜… Main</div>' : ''}
          <div class="upload-icon">ğŸ“·</div>
          <div class="upload-label">Tap to add<br>face photo</div>
          <input type="file" accept="image/*" capture="user" style="display:none">
        `;
        slot.onclick = () => slot.querySelector('input').click();
        slot.querySelector('input').onchange = (e) => handleUpload(e, slot, i);
        grid.appendChild(slot);
      }
    }
    
    async function handleUpload(e, slot, idx) {
      const file = e.target.files[0];
      if (!file) return;
      Sound.click();
      
      // é¡¯ç¤ºè™•ç†ä¸­ç‹€æ…‹
      slot.classList.add('processing');
      slot.classList.remove('filled', 'error');
      slot.innerHTML = `
        ${idx === 0 ? '<div class="slot-badge">â˜… Main</div>' : ''}
        <div class="upload-icon">â³</div>
        <div class="upload-label">Processing...</div>
        <input type="file" accept="image/*" capture="user" style="display:none">
      `;
      
      const reader = new FileReader();
      reader.onload = async (ev) => {
        try {
          // è™•ç†ä¸¦è£åˆ‡è‡‰éƒ¨
          const result = await FaceDetector.cropFace(ev.target.result);
          
          slot.classList.remove('processing');
          
          if (result.faceDetected || !FaceDetector.supported) {
            // æˆåŠŸåµæ¸¬åˆ°è‡‰éƒ¨æˆ–ä¸æ”¯æ´åµæ¸¬ï¼ˆä½¿ç”¨æ™ºæ…§è£åˆ‡ï¼‰
            photos[idx] = result.dataUrl;
            photoStatus[idx] = true;
            slot.classList.add('filled');
            slot.innerHTML = `
              <img src="${result.dataUrl}" alt="Face">
              ${idx === 0 ? '<div class="slot-badge">â˜… Main</div>' : ''}
              <div class="slot-status">âœ“ ${result.faceDetected ? 'Face detected' : 'Cropped'}</div>
              <input type="file" accept="image/*" capture="user" style="display:none">
            `;
            Sound.success();
            
            // é‡æ–°ç¶å®šé»æ“Šäº‹ä»¶
            slot.onclick = () => slot.querySelector('input').click();
            slot.querySelector('input').onchange = (e) => handleUpload(e, slot, idx);
          } else {
            // æ”¯æ´åµæ¸¬ä½†æ²’æœ‰æ‰¾åˆ°è‡‰éƒ¨
            slot.classList.add('error');
            slot.innerHTML = `
              ${idx === 0 ? '<div class="slot-badge">â˜… Main</div>' : ''}
              <div class="upload-icon">ğŸ˜•</div>
              <div class="upload-label">No face found<br>Tap to retry</div>
              <input type="file" accept="image/*" capture="user" style="display:none">
            `;
            Sound.error();
            showToast('ğŸ˜• No face detected! Please upload a photo with a clear face.');
            
            // é‡æ–°ç¶å®šé»æ“Šäº‹ä»¶
            slot.onclick = () => slot.querySelector('input').click();
            slot.querySelector('input').onchange = (e) => handleUpload(e, slot, idx);
          }
        } catch(err) {
          console.error('[Upload] Error:', err);
          slot.classList.remove('processing');
          slot.classList.add('error');
          Sound.error();
        }
      };
      reader.readAsDataURL(file);
    }
    
    // ========== éŠæˆ²é‚è¼¯ ==========
    function startGame() {
      // æª¢æŸ¥è‡³å°‘ä¸Šå‚³äº†ä¸€å¼µç…§ç‰‡
      const uploadedCount = photoStatus.filter(s => s).length;
      if (uploadedCount === 0) {
        Sound.error();
        showToast('ğŸ“¸ Please upload at least one face photo!');
        return;
      }
      
      Sound.click();
      score = 0;
      level = 1;
      target = 15;
      updateUI();
      createBoard();
      showPhase('game');
    }
    
    function createBoard() {
      board = [];
      // åªä½¿ç”¨æœ‰ä¸Šå‚³ç…§ç‰‡çš„ slot
      const availableTypes = [];
      for (let i = 0; i < 6; i++) {
        if (photoStatus[i] || typeof photos[i] === 'string' && !photos[i].startsWith('data:')) {
          availableTypes.push(i);
        }
      }
      
      // è‡³å°‘éœ€è¦ 3 ç¨®é¡å‹æ‰èƒ½ç©
      while (availableTypes.length < 3) {
        const emojis = ['ğŸ˜œ', 'ğŸ¤ª', 'ğŸ˜‚', 'ğŸ¥³', 'ğŸ˜', 'ğŸ¤“'];
        for (let i = 0; i < 6 && availableTypes.length < 3; i++) {
          if (!availableTypes.includes(i)) {
            photos[i] = emojis[i];
            availableTypes.push(i);
          }
        }
      }
      
      for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
        const typeIdx = Math.floor(Math.random() * availableTypes.length);
        board.push(availableTypes[typeIdx]);
      }
      
      // ç¢ºä¿æ²’æœ‰åˆå§‹åŒ¹é…
      let attempts = 0;
      while (findMatches().length > 0 && attempts < 100) {
        for (let i = 0; i < board.length; i++) {
          const typeIdx = Math.floor(Math.random() * availableTypes.length);
          board[i] = availableTypes[typeIdx];
        }
        attempts++;
      }
      renderBoard();
    }
    
    function renderBoard() {
      const boardEl = document.getElementById('game-board');
      boardEl.innerHTML = '';
      
      board.forEach((type, idx) => {
        const cell = document.createElement('div');
        cell.className = 'game-cell';
        cell.style.background = COLORS[type % COLORS.length];
        cell.draggable = true;
        
        if (typeof photos[type] === 'string' && photos[type].startsWith('data:')) {
          cell.innerHTML = `<img src="${photos[type]}">`;
        } else {
          cell.textContent = photos[type];
        }
        
        cell.ondragstart = () => { draggedIdx = idx; Sound.click(); };
        cell.ondragenter = (e) => { e.preventDefault(); };
        cell.ondragover = (e) => { e.preventDefault(); };
        cell.ondrop = (e) => { e.preventDefault(); handleSwap(idx); };
        cell.onclick = () => handleCellClick(idx);
        
        boardEl.appendChild(cell);
      });
    }
    
    function handleCellClick(idx) {
      Sound.click();
      const cells = document.querySelectorAll('.game-cell');
      
      if (selectedCell === null) {
        selectedCell = idx;
        cells[idx].classList.add('selected');
      } else {
        cells[selectedCell].classList.remove('selected');
        
        if (isAdjacent(selectedCell, idx)) {
          swapCells(selectedCell, idx);
        } else if (selectedCell !== idx) {
          Sound.invalid();
        }
        selectedCell = null;
      }
    }
    
    function handleSwap(targetIdx) {
      if (draggedIdx === null || draggedIdx === targetIdx) return;
      if (isAdjacent(draggedIdx, targetIdx)) {
        swapCells(draggedIdx, targetIdx);
      } else {
        Sound.invalid();
      }
      draggedIdx = null;
    }
    
    function isAdjacent(a, b) {
      const rowA = Math.floor(a / BOARD_SIZE), colA = a % BOARD_SIZE;
      const rowB = Math.floor(b / BOARD_SIZE), colB = b % BOARD_SIZE;
      return (Math.abs(rowA - rowB) + Math.abs(colA - colB)) === 1;
    }
    
    function swapCells(a, b) {
      Sound.swap();
      [board[a], board[b]] = [board[b], board[a]];
      renderBoard();
      
      setTimeout(() => {
        const matches = findMatches();
        if (matches.length > 0) {
          processMatches(matches);
        } else {
          Sound.invalid();
          [board[a], board[b]] = [board[b], board[a]];
          renderBoard();
        }
      }, 150);
    }
    
    function findMatches() {
      const matches = new Set();
      
      for (let row = 0; row < BOARD_SIZE; row++) {
        for (let col = 0; col < BOARD_SIZE - 2; col++) {
          const idx = row * BOARD_SIZE + col;
          if (board[idx] === board[idx + 1] && board[idx] === board[idx + 2]) {
            matches.add(idx); matches.add(idx + 1); matches.add(idx + 2);
          }
        }
      }
      
      for (let col = 0; col < BOARD_SIZE; col++) {
        for (let row = 0; row < BOARD_SIZE - 2; row++) {
          const idx = row * BOARD_SIZE + col;
          if (board[idx] === board[idx + BOARD_SIZE] && board[idx] === board[idx + BOARD_SIZE * 2]) {
            matches.add(idx); matches.add(idx + BOARD_SIZE); matches.add(idx + BOARD_SIZE * 2);
          }
        }
      }
      
      return Array.from(matches);
    }
    
    function processMatches(matches) {
      Sound.match();
      if (navigator.vibrate) navigator.vibrate(50);
      
      const cells = document.querySelectorAll('.game-cell');
      matches.forEach(idx => cells[idx].classList.add('matched'));
      
      setTimeout(() => {
        const points = matches.length;
        const mainCharMatches = matches.filter(idx => board[idx] === 0).length;
        score += points + mainCharMatches * 2;
        updateUI();
        
        matches.forEach(idx => board[idx] = -1);
        dropTiles();
        fillBoard();
        renderBoard();
        
        setTimeout(() => {
          const newMatches = findMatches();
          if (newMatches.length > 0) {
            processMatches(newMatches);
          } else {
            checkWin();
          }
        }, 200);
      }, 300);
    }
    
    function dropTiles() {
      for (let col = 0; col < BOARD_SIZE; col++) {
        let emptyRow = BOARD_SIZE - 1;
        for (let row = BOARD_SIZE - 1; row >= 0; row--) {
          const idx = row * BOARD_SIZE + col;
          if (board[idx] !== -1) {
            const newIdx = emptyRow * BOARD_SIZE + col;
            if (idx !== newIdx) {
              board[newIdx] = board[idx];
              board[idx] = -1;
            }
            emptyRow--;
          }
        }
      }
    }
    
    function fillBoard() {
      const availableTypes = [];
      for (let i = 0; i < 6; i++) {
        if (photoStatus[i] || (typeof photos[i] === 'string' && !photos[i].startsWith('data:'))) {
          availableTypes.push(i);
        }
      }
      if (availableTypes.length < 3) {
        for (let i = 0; i < 6 && availableTypes.length < 3; i++) {
          if (!availableTypes.includes(i)) availableTypes.push(i);
        }
      }
      
      for (let i = 0; i < board.length; i++) {
        if (board[i] === -1) {
          const typeIdx = Math.floor(Math.random() * availableTypes.length);
          board[i] = availableTypes[typeIdx];
        }
      }
    }
    
    function updateUI() {
      document.getElementById('score-display').textContent = score;
      document.getElementById('level-display').textContent = level;
      document.getElementById('target-display').textContent = target;
    }
    
    function checkWin() {
      if (score >= target) {
        Sound.levelUp();
        if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
        document.getElementById('final-score').textContent = score;
        document.getElementById('win-modal').classList.add('show');
      }
    }
    
    function nextLevel() {
      Sound.click();
      document.getElementById('win-modal').classList.remove('show');
      level++;
      target = 15 + level * 5;
      score = 0;
      updateUI();
      createBoard();
    }
    
    function pauseGame() {
      Sound.click();
      if (confirm('Return to lobby?')) {
        goToLobby();
      }
    }
  </script>
</body>
</html>
